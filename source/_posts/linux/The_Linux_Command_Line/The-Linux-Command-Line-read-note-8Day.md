---
title: 快乐的Linux命令行笔记-进程
date: 2019-02-06 22:11:47
categories:
- 读书笔记
- 快乐的Linux命令行
tags:
- 笔记
- 快乐的Linux命令行
- linux
---

[第一天的笔记-基本的命令和使用方法](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-1Day.html)
[第二天的笔记-操作文件](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-2Day.html)
[第三天的笔记-查阅命令文档并创建命令别名](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-3Day.html)
[第四天的笔记-重定向标准输入和输出以及处理查询结果](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-4Day.html)
[第五天的笔记-命令的展开](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-5Day.html)
[第六天的笔记-快捷键](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-6Day.html)
[第七天的笔记-文件权限](/linux/The_Linux_Command_Line/The-Linux-Command-Line-read-note-7Day.html)

# 总结
今天学习了如何查看进程, 将进程切换前后台, 向进程发送信号等。
<!--more-->
# 进程

查看对于当前终端的所有进程:

```shell
ps
```

查看所有进程, 不管是不是属于当前终端:

```shell
ps x
```

在查看所有进程时, `STAT` 那一列表示了进程状态。

| 状态 | 含义 |
| ---: | :--- |
| R | 运行中, 进程正在运行或准备运行 |
| S | 正在睡眠, 没有运行, 在等待着一个事件 |
| D | 不可中断睡眠, 进程正在等待者I/O, 比如说一个磁盘驱动器的I/O |
| T | 已停止, 已经指示进程停止运行 |
| Z | 一个死进程, 已经被终止的子进程, 但它的父进程还没有清空它 |
| < | 一个高优先级进程, 可能会给它更多重要的资源 |
| N | 低优先级进程, 当其他高优先级进程被服务了之后, 才会得到处理 |

显示属于每个用户的进程信息

```shell
ps aux
```

BSD风格的ps命令列标题

| 标题 | 含义 |
| ---: | :--- |
| USER | 用户ID.进程的所有者 |
| %CPU | 以百分比表示的CPU使用率 |
| %MEM | 以百分比表示的内存使用率 |
| VSZ | 虚拟内存大小 |
| RSS | 进程占用的物理内存的大小, 以千字节为单位 |
| START | 进程启动的时间, 若它的值超过24小时, 则用天表示 |

## 动态查看进程

```shell
top
```

下表是对该命令运行结果的说明:

| 行号 | 字段 | 意义 |
| :--: | :-- | :--- |
| 1 | top | 程序名 |
| | 22:43:00 | 当前时间 |
| | up 1:10 | 系统运行时间 |
| | 1 user | 有一个用户登录系统 |
| | load average: | 指等待运行的进程数目, 处于可以运行状态并共享CPU的进程个数, 第一个是最后60秒的平均值, 第二个是前5分钟的平均值, 最后一个是前15分钟的平均值。若平均值低于1.0, 则表示计算机不忙碌 |
| 2 | tasks: | 总结了进程数目和进程的状态 |
| 3 | %Cpu(s) | 描述了CPU正在进行的活动的特性 |
| | 0.0%us | 0.0%的CPU被用于用户进程, 这意味着进程在内核之外 |
| | 0.1%sy | 0.1%的CPU时间被用于系统进程 |
| | 0.0%ni | 0.0%的CPU时间被用于低优先级(nice)的进程 |
| | 100.0%id | 100%的CPU时间是空闲的 |
| | 0.0%wa | 0.0%的CPU时间来等待I/O |
| 4 | Mem: | 展示物理内存的使用情况 |
| 5 | Swap: | 展示交换分区(虚拟内存)的使用情况。|

在运行top程序时, h 显示程序的帮助屏幕, q 退出top程序

# 后台执行一个进程

```shell
xlogo &
```

在需要执行的命令后加`&`, shell会返回执行的进程的任务序号和id

```shell
jobs
```

该命令会列出从终端启动的任务列表, 包含了该任务的序号, 运行状态和id。

# 后台执行的进程切换到前台

```shell
fg %1
```

一个百分号跟随需要切换的任务的序号, 该程序会由后台切换到前台, 可以使用`ctrl-c`终止。

# 停止一个进程

使用ctrl-z停止一个进程, 使用fg命令恢复该进程, 或者使用bg命令将该进程切换到后台运行。

# 杀死一个进程

```shell
kill [pid]
# 或者
kill [jobspec] # 任务序号
```

使用kill命令或者特定的按键组合之后, 程序会收到操作系统发送给程序的一个信号, 信号是操作系统和程序之间的几种通信方式中的一种。程序可以对于监听的信号触发事件, 比如当程序接收到终止信号时, 可以做一些保存的工作。

## 通过kill命令给进程发送信号

如果命令没有指定信号, 那么默认情况下, 发送TERM(终止)信号。

> kill的一些常用信号

| 编号 | 名字 | 含义 |
| :--: | :--: | :-- |
| 1 | HUP | 	挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。<br>许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 |
| 2 | INT | 	中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。 |
| 9 | KILL | 	杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。 |
| 15 | TREM | 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。 |
| 18 | CONT | 继续。在一个停止信号后，这个信号会恢复进程的运行。 |
| 19 | STOP | 停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。 |

> 其他的系统常用信号

| 编号 | 名字 | 含义 |
| :--: | :--: | :-- |
| 3 | QUIT | 退出 |
| 11 | SEGV | 段错误(Segmentation Violation)。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。 |
| 20 | TSTP | 终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。 |
| 28 | WINCH | 	改变窗口大小(Window Change)。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 |

使用 `kill -l` 得到完整的信号列表。

## 通过kill命令给多个进程发送信号

语法:
```shell
killall [-u user] [-signal] name
```

## 其他和进程相关的命令

| 命令名 | 命令描述 |
| :----: | :----- |
|pstree | 输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。|
| vmstat | 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。 |
| xload |	一个图形界面程序，可以画出系统负载随时间变化的图形。 |
| tload | terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 |
